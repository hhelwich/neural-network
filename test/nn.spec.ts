import { NeuralNetwork } from '../src/nn'

/** Create some test neural network with fixed dimension and weights */
const nnWithConstantWeights = () => {
    const nn = new NeuralNetwork([4, 3, 2]);
    nn.weights[0] = [ // (input -> hidden) 3x4
        1/16, -2/16, 3/16, -4/16,
        5/16, -9/16, 7/16, -8/16,
        2/16, -1/16, 8/16, -7/16,
    ];
    nn.weights[1] = [ // (hidden -> output) 2x3
        5/8, 4/8, -7/8,
        1/8, -2/8, 6/8,
    ];
    return nn;
};

describe('NeuralNetwork', () => {

    it('maps input to correct output', () => {
        // GIVEN Neural network
        const nn = nnWithConstantWeights();
        // WHEN Maps input
        const out = nn.map([1/4, 2/4, -2/4, 3/4]);
        // THEN Returns expected hand verified output
        const x = expect(out)
        x.toBeAbout([
            0.5256248130827825, 0.5607451182402815
        ], 1e-16);
    });

    it('trains the correct weights', () => {
        /*
        Detailed calculation so it can be verified by hand:
        Input
        i = [0.25, 0.5, -0.5, 0.75]
        W0 = [0.0625, -0.125 , 0.1875, -0.25  ,
              0.3125, -0.5625, 0.4375, -0.5   ,
              0.125 , -0.0625, 0.5   , -0.4375]
        W1 = [0.625,  0.5 , -0.875,
              0.125, -0.25,  0.75 ]

        Forward
        a = W0 * i = [-0.328125, -0.796875, -0.578125]
        b = sigmoid(a) = [0.4186969093556867, 0.31069438321455395, 0.35936414516010196]
        c = W1 * b = [0.1025891329394919, 0.2441866267358988]
        d = sigmoid(c) = [0.5256248130827825, 0.5607451182402815]

        Backward
        t = [0.3, 0.7]

        error = t - d = [-0.22562481308278254, 0.13925488175971845]
        c' = sigmoid'(c, d) = [0.24934336895447246, 0.24631003060997422]
        f = c'^t * error = [-0.05625805101378413, 0.034299874188824596]

        grads = b * f^t = [-0.023555072085845973, 0.01436125131414975]
                          [-0.01747906046058057, 0.010656778255433657]
                          [-0.020217126410941942, 0.012326144966965996]

        foo = W1^t * f = [-0.030873797610012004, -0.036703994054098216, 0.07495070027867956]
        a' = sigmoid'(a, b) = [0.24338980745168257, 0.21416338345348188, 0.23022155633345112]

        ldelta = foo .* a' = [-0.007514367655603039, -0.007860651552882155, 0.017255266866439637]
        grr = i^t * ldelta = [-0.0018785919139007597, -0.0019651628882205387, 0.004313816716609909]
                             [-0.0037571838278015195, -0.003930325776441077, 0.008627633433219819]
                             [0.0037571838278015195, 0.003930325776441077, -0.008627633433219819]
                             [-0.0056357757417022794, -0.0058954886646616165, 0.012941450149829729]

        // Update weights

        baz = 0.2 * (grads | grr) = [-0.0047110144171691945, -0.0034958120921161143, -0.004043425282188389, 0.0028722502628299503, 0.0021313556510867315, 0.002465228993393199,
            -0.00037571838278015196, -0.0007514367655603039, 0.0007514367655603039, -0.001127155148340456, -0.00039303257764410776, -0.0007860651552882155, 0.0007860651552882155,
            -0.0011790977329323234, 0.0008627633433219819, 0.0017255266866439637, -0.0017255266866439637, 0.002588290029965946]
        weight + baz = [
           0.625, 0.5, -0.875,
           0.125, -0.25, 0.75,

           0.0625, -0.125, 0.1875, -0.25,
           0.3125, -0.5625, 0.4375, -0.5,
           0.125, -0.0625, 0.5, -0.4375] + baz
           = [
               0.6202889855828309, 0.49650418790788386, -0.8790434252821884,
               0.12787225026282995, -0.24786864434891326, 0.7524652289933932,

               0.06212428161721985, -0.1257514367655603,  0.1882514367655603, -0.25112715514834044,
               0.3121069674223559, -0.5632860651552882, 0.43828606515528823, -0.5011790977329323,
               0.12586276334332197, -0.06077447331335604, 0.49827447331335606, -0.43491170997003403]
        */

        // GIVEN Some neural network and input / output
        const nn = nnWithConstantWeights();
        const input = [1/4, 2/4, -2/4, 3/4];
        const output = [0.3, 0.7];
        // WHEN Trained for single input / output
        nn.train(input, output, 0.2);
        // THEN Adapts weights correctly
        expect(nn.weights[0]).toEqual([
            0.06212428161721985, -0.1257514367655603 , 0.1882514367655603 , -0.25112715514834044,
            0.3121069674223559 , -0.5632860651552882 , 0.43828606515528823, -0.5011790977329323 ,
            0.12586276334332197, -0.06077447331335604, 0.49827447331335606, -0.43491170997003403,
        ]);
        expect(nn.weights[1]).toEqual([
            0.6202889855828309 ,  0.49650418790788386, -0.8790434252821884,
            0.12787225026282995, -0.24786864434891326,  0.7524652289933932,
        ]);
    });

    it('maps to expected output after training', () => {
        // GIVEN Some neural network and input / output
        const nn = nnWithConstantWeights();
        const input = [1/4, 2/4, -2/4, 3/4];
        const target = [0.3, 0.7];
        // WHEN Trained for single input / output
        nn.train(input, target, 0.2);
        // THEN Learns input / output relation
        expect(nn.map([0.2, 0.8, -0.3, 0.42])).toEqual([0.5176947077655945, 0.5708750392306005]);
    });

});
